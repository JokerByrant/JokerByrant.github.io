---
title: 如何优化项目中的SHIT MOUNTAIN
tags: 后端技术
abbrlink: 45353
date: 2020-12-28 16:45:22
---

## 前言
最近经常接到要变更很久之前的功能的需求

## 软件开发原则---SOLID
`SOLID` 是五个软件开发原则的简称，它们分别是：`单一职责SRP(Single Responsibility Principle)`、`开放封闭原则OCP(Open Closed Principle)`、`里氏替换原则LSP(Liskov Substitution Principle)`、`接口隔离原则ISL(Interface Segregation Principle)`、`依赖倒置原则DIP(Dependency-Inversion Principle)`。
### `单一职责SRP`

### `开放封闭原则OCP`

### `里氏替换原则LSP`

### `接口隔离原则ISL`

### `依赖倒置原则DIP`

## 代码重构
推荐阅读：[《重构 改善既有代码的设计》](http://gdut_yy.gitee.io/doc-refact2/)

下面就说一说我从书中学到的一些技巧。

### 重构的原则
**在不改变软件可观察行为的前提下，对代码的结构进行调整**。
**可观察行为** 是指：经过重构之后的代码所做的事应该与重构之前大致一样，这里的一样是针对用户而言的。因为重构可能会对程序内部的代码结构进行调整，但对于用户而言，代码的功能仍与之前一样。
注意点：
1. 如果对代码的工作原理并不理解，那么就不要进行重构，因为这样很可能会破坏原有的逻辑。
2. 需求的变化使重构变得必要。如果一段代码能正常工作，并且不会再被修改，那么完全可以不去重构它。能改进之当然很好，但若没人需要去理解它，它就不会真正妨碍什么。

### 重构和性能优化
两者很相似，都需要修改代码，并且两者都不会改变程序的整体功能。他们的差别是在于最终目的：
* 重构是为了让代码**"更容易理解，更易于修改"**，这可能使程序运行得更快，也可能使程序运行得更慢。
* 在性能优化时，我只关心让程序运行得更快，最终得到的代码有可能更难理解和维护。

以前我在优化代码时，总是会担心优化后会不会性能变差了，但其实大多数时候我们的优化对性能的影响可以忽略不计。在聪明的编译器、现代的缓存技术面前，我们很多直觉都是不准确的。如果系统对性能的要求不高，那就更不用担心了。但也有例外的时候，可能我们的优化对性能产生了很显著的影响，但正如上面说的：重构是为了让代码**"更容易理解，更易于修改"**。所以保证可读性和易拓展性才是重构首先要考虑的，性能的调优可以在重构之后再进行。

### 两顶帽子
在进行软件开发时，应当让自己适应两种模式：**添加新功能** 和 **重构**。添加新功能时，不应该修改既有代码，只管添加新功能，这样任务的耗时才能被很好的掌握。重构时就不再添加功能，只管调整代码的结构。但当在添加新功能时，发现如果把代码再抽象一下，功能的添加会容易很多，那么这时候就可以换一顶帽子，切换到重构的工作中。但是如果这样的重构操作需要耗费几个小时，那么可以将手头的任务完成之后再进行。

### 重构的目的
总的来说，重构的终极目的就是：**添加功能更快**；**修复Bug更快**。

### 重构的手段
* 消除重复代码。
* 优化函数命名---函数名最好能清晰的指出函数做了什么工作。

### 自动化重构
[自动化重构](http://gdut_yy.gitee.io/doc-refact2/ch2.html#_2-10-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%87%8D%E6%9E%84)
IntelliJ IDEA就支持自动化重构，比如在修改一个文件名时，勾选了对应的选项后，就能发现不只文件名发生了变化，引用了该文件的代码也会相应的发生变化。这是因为IDEA在语法树上实现了代码导航、静态检查等功能，不仅处理了文本，同时也处理了语法树。

### 重构的时机
1. 神秘命名（Mysterious Name）。函数、变量、模块的命名会让人感到疑惑。
2. 重复代码（Duplicated Code）。重复代码不光是指代码完全一致，相似的代码也可算作其中一部分。通过移动语句重组代码的顺序，将相似的部分提炼成单独的函数。
3. 过长函数（Long Function）。以多个小函数取代一个长函数，将函数以功能划分成多个部分，每个部分用一个命名清晰的小函数替代。
4. 过长参数列表（Long Parameter List）。如果一个函数所需参数过多，可以使用**中转数据结构**来替代，这样参数列表可以简洁一些。
5. 发散式变化（Divergent Change）。如果某个模块经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了。当你看着一个类说：“呃，如果新加入一个数据库，我必须修改这 3 个函数；如果新出现一种金融工具，我必须修改这 4 个函数。”这就是发散式变化的征兆。

## 一些优化技巧
* 把复杂的代码块拆分成小的单元，也就是将一个很长的方法按照功能拆分成n个小的方法，这样的主要目的是便于理解。
* 在对相似代码进行重构时，可以使用**中转数据结构**来将公共部分代码抽象出来，使得抽象出的代码可以适应不同的场景。
* 抽象出的代码需要注意**数据的可变状态**，如果不希望数据在公共部分中发生变化，可以传入一个数据的副本进去。

## 编写单元测试